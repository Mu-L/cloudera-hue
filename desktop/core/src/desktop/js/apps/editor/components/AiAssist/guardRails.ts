/*
  Licensed to Cloudera, Inc. under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  Cloudera, Inc. licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/

import sqlParserRepository from 'parse/sql/sqlParserRepository';
import { SyntaxParser, SyntaxError } from 'parse/types';
import sqlStatementsParser, { ParsedSqlStatement } from 'parse/sqlStatementsParser';

import { findHallucinations } from './guardRailsHallucinations';

export enum GuardrailAlertType {
  UNSAFE_SQL = 'UNSAFE_SQL',
  HALLUCINATION = 'HALLUCINATION',
  SYNTAX_ERROR = 'SYNTAX_ERROR',
  INVALID_AI_RESPONSE = 'INVALID_AI_RESPONSE'
}

export const syntaxErrorWarning = (
  word: string,
  lineNumber: number,
  columnNumber: number
): string =>
  `The SQL statement contains a syntax error near "${word}" on line ${lineNumber} column 
  ${columnNumber} and will likely not execute. Please confirm that you understand.`;
const lossAlterWarning = `To prevent accidental loss or altering of data as a result of 
interacting with the AI assistant, you must confirm that you understand what this query 
does before executing it in the editor.`;
export const cteWarning = `CTE statements generated by the AI assistant are currently not 
automatically verified and can potentially contain unsafe sub statements. ${lossAlterWarning}`;
export const deleteWarning = (
  keyword: string
): string => `SQL statements starting with ${keyword} are not considered safe to execute because 
they delete data. To prevent accidental data loss as a result of interacting with the AI 
assistant, you must confirm that you understand what this query does before executing it 
in the editor.`;
export const alterWarning = (
  keyword: string
): string => `SQL statements starting with ${keyword} are not considered safe to execute because 
they modify data. To prevent accidental data loss as a result of interacting with the AI 
assistant, you must confirm that you understand what this query does before executing it 
in the editor.`;
export const defaultKeywordWarning = (
  keyword: string
): string => `SQL statements starting with ${keyword} are not considered safe 
to execute. ${lossAlterWarning}`;
export const hallucinationWarning = `This query might not return the expected results since it 
references table or column names that the AI assistant could not find. Please confirm 
that you understand.`;
const failedToParseWarning = `Unable to parse the query. ${lossAlterWarning}`;
export const rephrasActionMsg = `Rephrase your input with more context and try again.`;
export const exploreActionMsg = `Use the left assist to explore the metadata to find the missing 
tables and columns. Update the query accordingly or append the new information as AI 
Assistant input.`;
export const missingTableWarning = (tables: string): string =>
  `The AI assistant could not verify the existance of table ${tables}.`;
export const missingColumnWarning = (columns: string): string =>
  `The AI assistant could not verify the existance of column ${columns}.`;
export const invalidAiResponseMsg = `The AI responded in an unexpected way and the result could 
not be handled by Hue. Modify your input and try again.`;
export const invalidAiResponseTitle = 'The AI returned an invalid response';
export const hallucinationWarningTitle = 'Potential hallucination detected';

// A failed response results in all properties being null or empty strings
function checkAllPropertiesNullOrEmpty(obj: { [key: string]: string | null }): boolean {
  for (const key in obj) {
    if (obj[key] !== null && obj[key] !== '') {
      return false;
    }
  }
  return true;
}

function getFirstKeywordsInUppercase(sqlStatement: string) {
  const parsed: ParsedSqlStatement[] = sqlStatementsParser.parse(sqlStatement);
  const firstTokens = parsed.map(parsedObj => parsedObj?.firstToken?.toUpperCase());
  return firstTokens.filter(token => token !== undefined);
}

function validateFirstKeyword(keyword: string): { unsafe: boolean; details?: string } {
  let unsafe = true;
  let details;

  switch (keyword) {
    case 'SELECT':
    case 'DESCRIBE':
    case 'SHOW':
      unsafe = false;
      break;
    case 'WITH':
      details = cteWarning;
      break;
    case 'DELETE':
    case 'TRUNCATE':
    case 'DROP':
      details = deleteWarning(keyword);
      break;
    case 'INSERT':
    case 'UPDATE':
    case 'REPLACE':
    case 'LOAD':
    case 'ALTER':
    case 'MERGE':
    case 'UPSERT':
      details = alterWarning(keyword);
      break;
    default:
      details = defaultKeywordWarning(keyword);
      break;
  }
  return { unsafe, details };
}

export function hasUnsafeKeywords(sqlStatement: string): { unsafe: boolean; details?: string } {
  try {
    const firstKeywords = getFirstKeywordsInUppercase(sqlStatement);
    const onlyContainsComment = sqlStatement && firstKeywords.length === 0;

    if (!sqlStatement || onlyContainsComment) {
      return { unsafe: false };
    }

    const validations = firstKeywords.map(validateFirstKeyword);
    const invalidStatement = validations.find(validation => validation.unsafe === true);

    return invalidStatement || { unsafe: false };
  } catch (e) {
    console.error(e);
    return {
      unsafe: true,
      details: failedToParseWarning
    };
  }
}

/**
 * This function is used to wrap the AI assistant calls to the LLM in order to add guardrails.
 * It checks for syntax errors, unsafe SQL statements and hallucinations and attaches a
 * GuardrailAlert object to the return if any are found.
 */
export interface GuardrailAlert {
  actions?: Array<string>;
  confirmationText?: string;
  type: GuardrailAlertType;
  title: string;
  nql?: string;
  msg?: string;
  aiMsg?: string;
}

// eslint-disable-next-line  @typescript-eslint/no-explicit-any
export function withGuardrails(functionToGuard: (...args: any[]) => Promise<any>) {
  // eslint-disable-next-line  @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  return async (...args: any[]) => {
    const result = await functionToGuard(...args);
    const { nql, dialect } = args[0];
    const titleUnsafeSqlType = 'Potentially unsafe SQL statement';

    // Check for invalid AI response, i.e. all props are null or empty
    const { tableColumnsMetadata, ...apiResponse } = result;
    const invalidResponse = checkAllPropertiesNullOrEmpty(apiResponse);
    if (invalidResponse) {
      result.guardrailAlert = {
        type: GuardrailAlertType.INVALID_AI_RESPONSE,
        title: invalidAiResponseTitle,
        msg: invalidAiResponseMsg
      };
    } else if (!result.sql) {
      // If the response is valid but there is no SQL then there is no need for
      // further guardrails checks.
      return result;
    } else {
      // Check for SQL contining syntax error
      const syntaxParser: SyntaxParser = await sqlParserRepository.getSyntaxParser(dialect);
      const syntaxError = syntaxParser.parseSyntax('', result.sql.trim()) as SyntaxError;
      if (syntaxError) {
        result.guardrailAlert = {
          type: GuardrailAlertType.SYNTAX_ERROR,
          confirmationText: syntaxErrorWarning(
            syntaxError.text,
            syntaxError.loc.first_line,
            syntaxError.loc.last_column
          )
        };
      } else {
        // Check for unsafe SQL keywords like DELETE, ALTER, etc.
        const { unsafe, details } = hasUnsafeKeywords(result.sql);
        if (unsafe) {
          result.guardrailAlert = {
            type: GuardrailAlertType.UNSAFE_SQL,
            title: titleUnsafeSqlType,
            nql,
            confirmationText: details
          };
        } else {
          // Check for SQL hallucinations
          const { sql } = result;
          if (tableColumnsMetadata) {
            const { columns, tables } = await findHallucinations({
              sql,
              tableColumnsMetadata,
              dialect
            });
            if (columns.length || tables.length) {
              result.guardrailAlert = {
                type: GuardrailAlertType.HALLUCINATION,
                title: hallucinationWarningTitle,
                msg: `${columns.length ? missingColumnWarning(columns.join(',')) + '\n' : ''} ${
                  tables.length ? missingTableWarning(tables.join(',')) + '\n' : ''
                }`,
                confirmationText: hallucinationWarning,
                actions: [rephrasActionMsg, exploreActionMsg]
              };
            }
          }
        }
      }
    }

    // The tableColumnsMetadata is only needed by the guardrails so there is
    // no need to return it.
    delete result.tableColumnsMetadata;
    return result;
  };
}
